*1
        HLT
TMP1,   0
PRLGP,  PRLG
EPLGP,  EPLG
N3,     7775    / -3
P2,     2       / 2
P4,     4       / 4
*10
SP,     STACK-1 / Pointer to the top of the stack
BP,     STACK-1 / Pointer to the base of the stack segment for the current function
TMP2,   0
TMP3,   0
N4,     7774    / -4
N1,     7777    / -1
P3,     3       / 3
*20
REGS,
*50
STACK,
/ Commands
/ MQA=     7501
/ MQL=     7421
/ DVI=     7407
*400
/ std function printf
f01,    0
        TAD BP
        TAD P6F
        DCA TMP2
        TAD I TMP2
        TAD N1
        DCA TMP2      / Pointer to the fotmat string
        TAD BP
        TAD P10
        DCA TMP1      / Pointer to the args for paste
PRTFL,  TAD I TMP2    / Format string reading loop
        SNA
         JMP PRTFND
        DCA TMP3
        TAD TMP3
        TAD NPRCNT
        SNA CLA
         JMP PRTFPC
PRTFSD, TAD TMP3        / Usual character output
        TAD NLFF        / Check LF
        SZA CLA
         JMP NOTLFF
        TAD PCRF        / Print CR before LF
        TSF
         JMP .-1
        TLS
        CLA CLL

NOTLFF, TAD TMP3        / it is not LF
        TSF
         JMP .-1
        TLS
        CLA CLL
        JMP PRTFL
PRTFPC, TAD I TMP2      / Processing %
        TAD DTD
        SNA
         JMP PRTFD
        TAD DTPRCT
        SNA CLA
         JMP PRTFPT
        JMP PRTFL
PRTFD,  TAD I TMP1      / Output number (d)
        DCA TMP3
        TAD TMP1
        TAD P3
        DCA TMP1
        
        / Print the minus sign for negative number
        TAD TMP3
        SMA
         JMP PRTFPS
        CIA
        DCA TMP3
        TAD PMINUS
        TSF
         JMP .-1
        TLS

        / Print 3 digits (tens, hundreds and thousands)
PRTFPS, CLA CLL
        TAD P1000       / Save 1000
        DCA DVSR        /    in diviser
        TAD N3          / Savecounter
        DCA NUMCNT
        DCA NDSKP

DLOOP,  TAD TMP3
        MQL DVI         / Divide
DVSR,   0000
        DCA TMP3        / Save remainder
        CLA MQA         / Get quotient
        DCA NUMTMP

        TAD NUMTMP
        SZA CLA
         JMP PRNT
        TAD NDSKP
        SZA CLA
         JMP PRNT
        JMP DLEND

PRNT,   TAD NUMTMP
        TAD DIGGEN      / Create symbole code of digit
        TSF             / Print digit
         JMP .-1
        TLS
        CLA

DLEND,  ISZ NUMCNT
         JMP .+2
        JMP DLPEXT

        / Divide diviser by 10
        TAD DVSR
        MQL DVI
        0012            / 10
        CLA MQA
        DCA DVSR

        JMP DLOOP

        / Print ones
DLPEXT, TAD TMP3
	TAD DIGGEN
        DCA TMP3
        JMP PRTFSD

PRTFPT, TAD PPRCNT      / Print %
        DCA TMP3
        JMP PRTFSD
PRTFND, TAD BP         / Exit loop
        DCA SP
        ISZ BP
        TAD I BP
        DCA BP
        JMP I f01

NUMTMP, 0
NDSKP,  0               / If 0, skip digit
NUMCNT, 0
PCRF,   0015            / CR
PPRCNT, 0045            / '%'
PMINUS, 0055            / '-'
NPRCNT, 7733            / -'%'
NLFF,   7766            / -LF
DTD,    7634            / Detect 'd' 
DTPRCT, 0077            / Detect '%' after 'd'
P6F,    6               / 6
P10,	0012		/ 10
P1000,	1750		/ 1000
DIGGEN,	0060		/ Summand for getting the digit symbol

*600

/ std function puts
f00,    0
        TAD BP
        TAD P6S
        DCA TMP2
        TAD I TMP2
        TAD N1
        DCA TMP2
PTSL,   TSF
         JMP .-1
        TAD I TMP2
        SNA
         JMP PTSEND

        / Check LF
        DCA TMP3
        TAD TMP3
        TAD NLFS
        SZA CLA
         JMP NOTLFS
        TAD CRS         / Print CR before LF
        TSF
         JMP .-1
        TLS
        CLA CLL

NOTLFS, TAD TMP3
        TLS
        CLA
        JMP PTSL
PTSEND, TAD CRS
        TLS
        TSF
         JMP .-1
        TAD LFFTCR
        TLS
        CLA

        TAD BP
        DCA SP
        ISZ BP
        TAD I BP
        DCA BP

        JMP I f00
P6S,    6       / 6
CRS,    0015
LFFTCR, 7775
NLFS,   7766            / -LF

/ Function prologue
PRLG,   0
        / Save pointer to stack registers
        TAD BP
        IAC
        DCA TMP2
        TAD SP
        DCA I TMP2
        / Save counter
        TAD I PRLG
        SNA
         JMP SKPPRG     / Skip if nothing to save
        DCA TMP1        / TMP1 - counter
        / Save pointer to registers for read
        TAD REGSP
        DCA TMP2        / TMP2 - pointer to registers for read
        / Registers save loop
PRLGC,  TAD I TMP2      / Read register
        DCA I SP       / Save register to stack
        ISZ TMP1
         JMP PRLGC
        / Exit loop
SKPPRG, ISZ PRLG        / Skip arg
        JMP I PRLG      / jump back to function

/ Function epilogue
EPLG,   0
        / Save counter
        TAD I EPLG
        SNA
         JMP SKPPLG     / Skip if nothing to restore
        DCA TMP1        / TMP1 - counter
        / Save pointer to stack registers
        TAD BP
        IAC
        DCA TMP2
        TAD I TMP2
        DCA TMP2        / TMP2 - pointer to registers for read
        / Save pointer to registers for restore
        TAD REGSP
        DCA TMP3        / TMP2 - pointer to registers for restore
        / Restore loop
EPLGC,  TAD I TMP2      / Read stack register
        DCA I TMP3      / Save register
        ISZ TMP1
         JMP EPLGC
        / Exit loop
SKPPLG, / Restore SP
        TAD BP
        TAD N1
        DCA SP
        / Restore BP
        TAD I BP
        DCA BP
        / Return from function
        TAD SP
        DCA TMP2
        TAD I TMP2
        DCA TMP1
        JMP I TMP1
REGSP,  REGS-1
/ main
f02,	0
	TAD .-1
	SNA
	 JMP MAINSP
	DCA I BP
	JMS I PRLGP
	0
MAINSP,
	TAD SP
	TAD P2
	DCA TMP1
	TAD BP
	DCA I TMP1
	TAD SP
	DCA BP
	TAD TMP1
	TAD P4
	DCA SP

	TAD d00l00
	DCA I SP
	DCA I SP
	DCA I SP

	JMS I f00l01 / puts

	TAD BP
	TAD P2
	DCA TMP2
	DCA I TMP2
	DCA I TMP2
	DCA I TMP2

	HLT


f00l01,	f00
f02l00,	f02
d00l00,	d00
DECIMAL
d00,	104
	101
	108
	108
	111
	112
	101
	0
OCTAL
*200
	KCC
	TPC
	JMP I MAINP
MAINP,	f02+1
